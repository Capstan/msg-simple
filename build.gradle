import java.lang.reflect.Modifier

/*
 * Copyright (c) 2013, Francis Galiegue <fgaliegue@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the Lesser GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * Lesser GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
apply(plugin: "java")
apply(plugin: "maven")
apply(plugin: "signing")

/*
 * Base variables. Note: project name is in settings.gradle
 */
group = "com.github.fge"
version = "0.7-SNAPSHOT"

/*
 * Compiler guidance
 */
sourceCompatibility = 1.6
targetCompatibility = 1.6

/*
 * Repositories to use
 */
repositories
{
    mavenCentral()
}

/*
 * List of dependencies
 *
 * Transitive is sort of like Maven"s provided, except it won"t find its way
 * into runtime dependencies
 */
dependencies
{
    compile(group: "com.github.fge", name: "btf", version: "1.0")
    compile(group: "com.google.code.findbugs", name: "jsr305", version: "2.0.1")
    {
        transitive = true
    }
    testCompile(group: "org.testng", name: "testng", version: "6.8")
    {
        exclude(group: "junit", module: "junit")
        exclude(group: "org.beanshell", module: "bsh")
        exclude(group: "org.yaml", module: "snakeyaml")
    }
    testCompile(group: "org.mockito", name: "mockito-core", version: "1.9.5")
}

jar
{
    manifest.attributes(provider: "gradle")
}

/*
 * Necessary! Otherwise TestNG will not be used...
 */
test
{
    useTestNG()
}

/*
 * Necessary to generate the source and javadoc jars
 */
task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = "sources"
    from sourceSets.main.allSource
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = "javadoc"
    from javadoc.destinationDir
}

artifacts {
    archives jar
    archives sourcesJar
    archives javadocJar
}

signing {
    sign configurations.archives
}

uploadArchives {
    repositories {
        mavenDeployer {
            beforeDeployment {
                MavenDeployment deployment -> signing.signPom(deployment)
            }

            repository(url: sonatypeRepoURI) {
                authentication(userName: sonatypeUsername,
                    password: sonatypePassword)
            }

            pom.project {
                name rootProject.name
                packaging "jar"
                description "A lightweight, fully compatible, UTF-8/printf() capable alternative to Java's ResourceBundle"
                url "http://github.com/fge/msg-simple"

                scm {
                    url "scm:git@github.com:fge/msg-simple.git"
                    connection "scm:git@github.com:fge/msg-simple.git"
                    developerConnection "scm:git@github.com:fge/msg-simple.git"
                }

                licenses {
                    license {
                        name "Lesser General Public License, version 3 or greater"
                        url "http://www.gnu.org/licenses/lgpl.html"
                        distribution "repo"
                    }
                }

                developers {
                    developer {
                        id "fge"
                        name "Francis Galiegue"
                        email "fgaliegue@gmail.com"
                    }
                }
            }
        }
    }
}

/*
 * TEST CODE
 */

project.ext({
    dotClass = ".class";
    runtimeURLs = sourceSets.main.runtimeClasspath.collect({
        it.toURI().toURL()
    }) as URL[];
    classpathURI = sourceSets.main.output.classesDir.canonicalFile.toURI();
    classLoader = URLClassLoader.newInstance(runtimeURLs);
    serviceClasses = [
        "com.github.fge.msgsimple.source.MessageSource",
        "com.github.fge.msgsimple.provider.MessageSourceProvider"
    ];
    serviceMap = new HashMap<Class<?>, List<String>>();
    tree = fileTree(classpathURI.path)
        .filter({ it.isFile() && it.name.endsWith(dotClass); }); // FileTree
    resourceURI = sourceSets.main.output.resourcesDir.canonicalFile.toURI()
        .resolve("META-INF/services/"); // Ending '/' is critical!
})

/*
 * Action!
 */
fillServiceMap();
tree.each() {
    File candidate ->
        serviceMap.each() {
            key, value ->
                final String className = toClassName(candidate);
                if (isImplementationOf(key, className))
                    value.add(className);
        }
};

println(serviceMap);
println(resourceURI);


createServicesDirectory();

serviceMap.each() {
    name, list ->
        if (list.empty)
            return;
        final String path = resourceURI.resolve(name.canonicalName).getPath();
        new File(path).withWriter {
            out -> list.each() { out.writeLine(it); }
        };
}
/*
 * Methods
 */

void createServicesDirectory()
{
    final File file = new File(resourceURI.getPath());
    if (file.exists()) {
        if (!file.directory)
            throw new IOException("file " + file + " exists but is not a directory");
        return;
    }
    if (!file.mkdirs())
        throw new IOException("failed to create META-INF/services directory");
}

String toClassName(final File file)
{
    final URI uri = file.canonicalFile.toURI();
    final String path = classpathURI.relativize(uri).getPath();
    return path.substring(0, path.length() - dotClass.length())
        .replace("/", ".");
}

boolean isImplementationOf(final Class<?> baseClass, final String className)
{
    final Class<?> c = classLoader.loadClass(className);
    final int modifiers = c.modifiers;
    if (c.anonymousClass)
        return false;
    if (c.interface)
        return false;
    if (c.enum)
        return false;
    if (Modifier.isAbstract(modifiers))
        return false;
    return Modifier.isPublic(modifiers) && baseClass.isAssignableFrom(c);
}

void fillServiceMap()
{
    serviceClasses.each() {
        serviceMap.put(classLoader.loadClass(it), new ArrayList<String>());
    };
}
