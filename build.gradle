/*
 * Copyright (c) 2013, Francis Galiegue <fgaliegue@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the Lesser GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * Lesser GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
apply(plugin: "java")
apply(plugin: "maven")
apply(plugin: "signing")

/*
 * Base variables. Note: project name is in settings.gradle
 */
group = "com.github.fge"
version = "0.7-SNAPSHOT"

/*
 * Compiler guidance
 */
sourceCompatibility = 1.6
targetCompatibility = 1.6

/*
 * Repositories to use
 */
repositories
{
    mavenCentral()
}

/*
 * List of dependencies
 *
 * Transitive is sort of like Maven"s provided, except it won"t find its way
 * into runtime dependencies
 */
dependencies
{
    compile(group: "com.github.fge", name: "btf", version: "1.0")
    compile(group: "com.google.code.findbugs", name: "jsr305", version: "2.0.1")
    {
        transitive = true
    }
    testCompile(group: "org.testng", name: "testng", version: "6.8")
    {
        exclude(group: "junit", module: "junit")
        exclude(group: "org.beanshell", module: "bsh")
        exclude(group: "org.yaml", module: "snakeyaml")
    }
    testCompile(group: "org.mockito", name: "mockito-core", version: "1.9.5")
}

jar
{
    manifest.attributes(provider: "gradle")
}

/*
 * Necessary! Otherwise TestNG will not be used...
 */
test
{
    useTestNG()
}

/*
 * Necessary to generate the source and javadoc jars
 */
task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = "sources"
    from sourceSets.main.allSource
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = "javadoc"
    from javadoc.destinationDir
}

artifacts {
    archives jar
    archives sourcesJar
    archives javadocJar
}

signing {
    sign configurations.archives
}

uploadArchives {
    repositories {
        mavenDeployer {
            beforeDeployment {
                MavenDeployment deployment -> signing.signPom(deployment)
            }

            repository(url: sonatypeRepoURI) {
                authentication(userName: sonatypeUsername,
                    password: sonatypePassword)
            }

            pom.project {
                name rootProject.name
                packaging "jar"
                description "A lightweight, fully compatible, UTF-8/printf() capable alternative to Java's ResourceBundle"
                url "http://github.com/fge/msg-simple"

                scm {
                    url "scm:git@github.com:fge/msg-simple.git"
                    connection "scm:git@github.com:fge/msg-simple.git"
                    developerConnection "scm:git@github.com:fge/msg-simple.git"
                }

                licenses {
                    license {
                        name "Lesser General Public License, version 3 or greater"
                        url "http://www.gnu.org/licenses/lgpl.html"
                        distribution "repo"
                    }
                }

                developers {
                    developer {
                        id "fge"
                        name "Francis Galiegue"
                        email "fgaliegue@gmail.com"
                    }
                }
            }
        }
    }
}

/*
 * TEST CODE
 */

final int CLASS_SUFFIX = ".class".length();
final URLClassLoader classLoader = this.class.classLoader;
// Where the classes are: OK
final File classesDir = sourceSets.main.output.classesDir;
final String basePath = classesDir.getCanonicalPath();

// Add them to the classloader: OK
classLoader.addURL(classesDir.toURI().toURL())

// Recurse over each file
classesDir.eachFileRecurse {
    // You "return" from a closure, you do not "continue"...
    if (!isPotentialClass(it))
        return;

    // Transform into a class name
    final String path = it.getAbsolutePath();
    final String name = path.substring(basePath.length() + 1);
    final String className = name.substring(0, name.length() - CLASS_SUFFIX)
        .replace('/', '.');

    // Try and load it
    try {
        classLoader.loadClass(className);
        println(className);
    } catch (NoClassDefFoundError ignored) {
        println("failed to load " + className + ": " + ignored);
    }
}

boolean isPotentialClass(final File file)
{
    return file.isFile() && file.name.endsWith(".class")
}
